#!/bin/bash

# Parallel Pok√©mon Data Fetching Script
# Fetches data for multiple Pok√©mon simultaneously using background processes
# Includes proper process management and synchronization

# Define variables
API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"
ERROR_FILE="parallel_errors.txt"
SUCCESS_FILE="parallel_success.txt"
PROCESS_DIR="process_info"
MAX_RETRIES=3
RETRY_DELAY=2

# Pok√©mon list to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Colors for output formatting
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log messages with timestamps
log_message() {
    local message="$1"
    local type="$2"
    local pokemon="$3"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$type" in
        "error")
            echo "[$timestamp] ERROR [$pokemon]: $message" >> "$ERROR_FILE"
            ;;
        "success")
            echo "[$timestamp] SUCCESS [$pokemon]: $message" >> "$SUCCESS_FILE"
            ;;
    esac
}

# Function to setup directories
setup_directories() {
    # Create output directory
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
        if [[ $? -eq 0 ]]; then
            echo "üìÅ Created directory: $OUTPUT_DIR"
        else
            echo -e "${RED}‚ùå Failed to create directory: $OUTPUT_DIR${NC}"
            exit 1
        fi
    fi
    
    # Create process tracking directory
    if [[ ! -d "$PROCESS_DIR" ]]; then
        mkdir -p "$PROCESS_DIR"
    fi
    
    # Clean up old log files
    > "$ERROR_FILE"
    > "$SUCCESS_FILE"
}

# Function to make API request with retry logic
fetch_pokemon_with_retry() {
    local pokemon_name="$1"
    local api_url="${API_BASE_URL}/${pokemon_name}"
    local output_file="${OUTPUT_DIR}/${pokemon_name}.json"
    local process_file="${PROCESS_DIR}/${pokemon_name}.status"
    local attempt=1
    local max_attempts=$((MAX_RETRIES + 1))
    
    # Write initial status
    echo "FETCHING" > "$process_file"
    
    echo "[$$] Starting fetch for ${pokemon_name}..."
    
    while [[ $attempt -le $max_attempts ]]; do
        if [[ $attempt -gt 1 ]]; then
            local retry_delay=$((RETRY_DELAY * (2 ** (attempt - 2))))
            echo "[$$] Retry attempt $((attempt - 1))/$MAX_RETRIES for $pokemon_name (waiting ${retry_delay}s)"
            sleep $retry_delay
        fi
        
        # Make the API request
        local response
        response=$(curl -s -S -f -w "%{http_code}" --connect-timeout 10 --max-time 30 "$api_url" 2>/dev/null)
        local curl_exit_code=$?
        
        # Check if curl command succeeded
        if [[ $curl_exit_code -ne 0 ]]; then
            if [[ $attempt -eq $max_attempts ]]; then
                echo "FAILED" > "$process_file"
                log_message "Network error: curl failed with exit code $curl_exit_code (all $MAX_RETRIES retries exhausted)" "error" "$pokemon_name"
                echo "[$$] ‚ùå Failed to fetch data for $pokemon_name after $MAX_RETRIES retries (Network error)"
                return 1
            else
                echo "[$$] ‚ö†Ô∏è Network error for $pokemon_name (attempt $attempt/$max_attempts)"
                ((attempt++))
                continue
            fi
        fi
        
        # Extract HTTP status code and response body
        local http_status="${response: -3}"
        response="${response%???}"
        
        # Check if the request was successful
        if [[ "$http_status" -eq 200 ]]; then
            # Validate JSON before saving
            if echo "$response" | jq empty >/dev/null 2>&1; then
                # Save the response to the output file
                echo "$response" > "$output_file"
                echo "SUCCESS" > "$process_file"
                log_message "Data saved successfully" "success" "$pokemon_name"
                if [[ $attempt -gt 1 ]]; then
                    echo "[$$] ‚úÖ Saved data to ${output_file} (succeeded on attempt $attempt)"
                else
                    echo "[$$] ‚úÖ Saved data to ${output_file}"
                fi
                return 0
            else
                if [[ $attempt -eq $max_attempts ]]; then
                    echo "FAILED" > "$process_file"
                    log_message "Invalid JSON response received (all $MAX_RETRIES retries exhausted)" "error" "$pokemon_name"
                    echo "[$$] ‚ùå Failed to save data for $pokemon_name after $MAX_RETRIES retries (Invalid JSON)"
                    return 1
                else
                    echo "[$$] ‚ö†Ô∏è Invalid JSON for $pokemon_name (attempt $attempt/$max_attempts)"
                    ((attempt++))
                    continue
                fi
            fi
        else
            # Handle different HTTP error codes
            local error_msg
            local should_retry=true
            
            case "$http_status" in
                404)
                    error_msg="Pok√©mon '$pokemon_name' not found (HTTP 404)"
                    should_retry=false
                    ;;
                429)
                    error_msg="Rate limit exceeded (HTTP 429)"
                    if [[ $attempt -lt $max_attempts ]]; then
                        echo "[$$] ‚ö†Ô∏è Rate limit hit for $pokemon_name, extending delay..."
                        sleep 10
                    fi
                    ;;
                500|502|503|504)
                    error_msg="Server error (HTTP $http_status)"
                    ;;
                *)
                    error_msg="API request failed with HTTP status: $http_status"
                    ;;
            esac
            
            if [[ $attempt -eq $max_attempts ]] || [[ "$should_retry" == false ]]; then
                echo "FAILED" > "$process_file"
                if [[ "$should_retry" == false ]]; then
                    log_message "$error_msg (no retry - permanent error)" "error" "$pokemon_name"
                else
                    log_message "$error_msg (all $MAX_RETRIES retries exhausted)" "error" "$pokemon_name"
                fi
                echo "[$$] ‚ùå Failed to fetch data for $pokemon_name ($error_msg)"
                return 1
            else
                echo "[$$] ‚ö†Ô∏è $error_msg for $pokemon_name (attempt $attempt/$max_attempts)"
                ((attempt++))
                continue
            fi
        fi
    done
    
    return 1
}

# Function to monitor background processes with jobs command
monitor_processes() {
    local total_pokemon=${#POKEMON_LIST[@]}
    local completed=0
    local max_wait=300  # Maximum wait time in seconds (5 minutes)
    local wait_time=0
    
    echo -e "${BLUE}üìä Monitoring $total_pokemon parallel processes...${NC}"
    
    while [[ $completed -lt $total_pokemon ]] && [[ $wait_time -lt $max_wait ]]; do
        completed=0
        local running_processes=()
        
        # Use jobs command to check background processes
        local active_jobs=$(jobs -r | wc -l)
        if [[ $active_jobs -gt 0 ]]; then
            echo -e "${BLUE}Active background jobs: $active_jobs${NC}"
            jobs -l
        fi
        
        # Check status of each Pok√©mon
        for pokemon in "${POKEMON_LIST[@]}"; do
            local process_file="${PROCESS_DIR}/${pokemon}.status"
            if [[ -f "$process_file" ]]; then
                local status=$(cat "$process_file")
                case "$status" in
                    "SUCCESS"|"FAILED")
                        ((completed++))
                        ;;
                    "FETCHING")
                        running_processes+=("$pokemon")
                        ;;
                esac
            fi
        done
        
        # Display progress
        local progress_percent=$((completed * 100 / total_pokemon))
        echo -ne "\r${BLUE}Progress: [$completed/$total_pokemon] $progress_percent% | Running: ${running_processes[*]}${NC}                    "
        
        if [[ $completed -lt $total_pokemon ]]; then
            sleep 2
            ((wait_time += 2))
        fi
    done
    
    echo ""  # New line after progress display
    
    if [[ $wait_time -ge $max_wait ]]; then
        echo -e "${RED}‚ö†Ô∏è Timeout reached while waiting for processes to complete${NC}"
        echo "Killing remaining background processes..."
        # Kill any remaining background jobs
        jobs -p | xargs -r kill
        return 1
    fi
    
    return 0
}

# Function to display detailed results
display_results() {
    local successful_files=$(find "$OUTPUT_DIR" -name "*.json" -type f 2>/dev/null | wc -l)
    local total_pokemon=${#POKEMON_LIST[@]}
    local failed_count=$((total_pokemon - successful_files))
    
    echo ""
    echo "=== Parallel Processing Results ==="
    
    # Show individual results
    for pokemon in "${POKEMON_LIST[@]}"; do
        local process_file="${PROCESS_DIR}/${pokemon}.status"
        local output_file="${OUTPUT_DIR}/${pokemon}.json"
        
        if [[ -f "$process_file" ]]; then
            local status=$(cat "$process_file")
            case "$status" in
                "SUCCESS")
                    local file_size=$(ls -lh "$output_file" 2>/dev/null | awk '{print $5}')
                    echo -e "  ${GREEN}‚úÖ $pokemon${NC} - Successfully fetched ($file_size)"
                    ;;
                "FAILED")
                    echo -e "  ${RED}‚ùå $pokemon${NC} - Failed to fetch"
                    ;;
                *)
                    echo -e "  ${YELLOW}‚ö†Ô∏è $pokemon${NC} - Unknown status: $status"
                    ;;
            esac
        else
            echo -e "  ${RED}‚ùå $pokemon${NC} - No status file found"
        fi
    done
    
    echo ""
    echo "üìä Summary:"
    echo "  Total Pok√©mon: $total_pokemon"
    echo -e "  Successfully fetched: ${GREEN}$successful_files${NC}"
    
    if [[ $failed_count -gt 0 ]]; then
        echo -e "  Failed requests: ${RED}$failed_count${NC}"
        if [[ -s "$ERROR_FILE" ]]; then
            echo "  Check $ERROR_FILE for error details."
        fi
    fi
    
    echo ""
    echo "üìÇ Output directory: $OUTPUT_DIR"
    
    if [[ $successful_files -gt 0 ]]; then
        echo "üìÑ Files created:"
        ls -1 "$OUTPUT_DIR"/*.json 2>/dev/null | sed 's/^/  /'
    fi
    
    # Show timing information if available
    if [[ -s "$SUCCESS_FILE" ]]; then
        echo ""
        echo "‚è±Ô∏è Timing details:"
        echo "First completion: $(head -n1 "$SUCCESS_FILE" | cut -d']' -f1 | tr -d '[')"
        echo "Last completion:  $(tail -n1 "$SUCCESS_FILE" | cut -d']' -f1 | tr -d '[')"
    fi
}

# Function to cleanup temporary files and kill background processes
cleanup() {
    echo "üßπ Cleaning up temporary files and processes..."
    
    # Check for any remaining background jobs
    local remaining_jobs=$(jobs -p)
    if [[ -n "$remaining_jobs" ]]; then
        echo "Terminating remaining background processes..."
        jobs -p | xargs -r kill
        sleep 1
        # Force kill if still running
        jobs -p | xargs -r kill -9 2>/dev/null
    fi
    
    # Remove temporary directory
    rm -rf "$PROCESS_DIR"
}

# Function to validate prerequisites
check_prerequisites() {
    if ! command -v curl >/dev/null 2>&1; then
        echo -e "${RED}‚ùå curl is not installed. Please install curl to use this script.${NC}"
        exit 1
    fi
    
    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${YELLOW}‚ö†Ô∏è jq is not installed. JSON validation will be skipped.${NC}"
    fi
}

# Main execution function
main() {
    echo "=== Parallel Pok√©mon Data Fetching ==="
    echo "Target API: $API_BASE_URL"
    echo "Output directory: $OUTPUT_DIR"
    echo "Pok√©mon to fetch: ${POKEMON_LIST[*]}"
    echo "Max retries per Pok√©mon: $MAX_RETRIES"
    echo "Processing mode: PARALLEL"
    echo ""
    
    # Setup trap for cleanup on exit
    trap cleanup EXIT
    
    # Check prerequisites
    check_prerequisites
    
    # Setup directories
    setup_directories
    
    # Start parallel processes
    echo -e "${BLUE}üöÄ Starting parallel fetch processes...${NC}"
    local pids=()
    
    for pokemon in "${POKEMON_LIST[@]}"; do
        echo "Starting background process for $pokemon..."
        fetch_pokemon_with_retry "$pokemon" &
        pids+=($!)
    done
    
    echo -e "${BLUE}‚úÖ All ${#POKEMON_LIST[@]} background processes started${NC}"
    echo "Process IDs: ${pids[*]}"
    
    # Display current background jobs
    echo -e "${BLUE}Background jobs status:${NC}"
    jobs -l
    echo ""
    
    # Monitor processes
    monitor_processes
    
    # Wait for all background processes to complete
    echo -e "${BLUE}‚è≥ Waiting for all background processes to complete...${NC}"
    
    # Check if any jobs are still running before waiting
    if [[ $(jobs -r | wc -l) -gt 0 ]]; then
        echo "Waiting for $(jobs -r | wc -l) remaining background jobs..."
        for pid in "${pids[@]}"; do
            wait $pid
        done
    fi
    
    # Final jobs check
    if [[ $(jobs | wc -l) -gt 0 ]]; then
        echo "Final background jobs status:"
        jobs -l
    else
        echo "All background processes completed successfully."
    fi
    
    # Display results
    display_results
    
    # Final status
    local successful_files=$(find "$OUTPUT_DIR" -name "*.json" -type f 2>/dev/null | wc -l)
    local total_pokemon=${#POKEMON_LIST[@]}
    
    if [[ $successful_files -eq $total_pokemon ]]; then
        echo -e "${GREEN}üéâ All Pok√©mon data fetched successfully in parallel!${NC}"
        exit 0
    else
        echo -e "${YELLOW}‚ö†Ô∏è Some requests failed. Check the results above.${NC}"
        exit 1
    fi
}

# Run the main function
main "$@"
