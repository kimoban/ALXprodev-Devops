#!/bin/bash

# Batch Pok√©mon Data Retrieval Script
# Fetches data for multiple Pok√©mon from the API and saves to separate files
# Includes rate limiting and error handling

# Define variables
API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"
ERROR_FILE="batch_errors.txt"
DELAY_SECONDS=2  # Delay between requests to handle rate limiting
MAX_RETRIES=3   # Maximum number of retry attempts per Pok√©mon
RETRY_DELAY=2   # Initial delay between retries (will increase exponentially)

# Pok√©mon list to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Colors for output formatting
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to log errors
log_error() {
    local error_message="$1"
    local pokemon_name="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] ERROR [$pokemon_name]: $error_message" >> "$ERROR_FILE"
}

# Function to create output directory
setup_output_directory() {
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
        if [[ $? -eq 0 ]]; then
            echo "üìÅ Created directory: $OUTPUT_DIR"
        else
            echo -e "${RED}‚ùå Failed to create directory: $OUTPUT_DIR${NC}"
            exit 1
        fi
    fi
}

# Function to make a single API request attempt
make_api_request() {
    local pokemon_name="$1"
    local api_url="${API_BASE_URL}/${pokemon_name}"
    
    # Make the API request using curl
    local response
    local curl_exit_code
    
    # Use curl with timeout and proper error handling
    response=$(curl -s -S -f -w "%{http_code}" --connect-timeout 10 --max-time 30 "$api_url" 2>/dev/null)
    curl_exit_code=$?
    
    # Return curl exit code and response
    echo "$response"
    return $curl_exit_code
}

# Function to fetch data for a single Pok√©mon with retry logic
fetch_pokemon_data() {
    local pokemon_name="$1"
    local output_file="${OUTPUT_DIR}/${pokemon_name}.json"
    local attempt=1
    local max_attempts=$((MAX_RETRIES + 1))  # +1 for initial attempt
    
    echo "Fetching data for ${pokemon_name}..."
    
    while [[ $attempt -le $max_attempts ]]; do
        if [[ $attempt -gt 1 ]]; then
            local retry_delay=$((RETRY_DELAY * (2 ** (attempt - 2))))  # Exponential backoff
            echo -e "${YELLOW}üîÑ Retry attempt $((attempt - 1))/$MAX_RETRIES for $pokemon_name (waiting ${retry_delay}s)${NC}"
            sleep $retry_delay
        fi
        
        # Make the API request
        local response
        response=$(make_api_request "$pokemon_name")
        local curl_exit_code=$?
        
        # Check if curl command succeeded
        if [[ $curl_exit_code -ne 0 ]]; then
            local error_msg="Network error: curl failed with exit code $curl_exit_code"
            
            if [[ $attempt -eq $max_attempts ]]; then
                log_error "$error_msg (all $MAX_RETRIES retries exhausted)" "$pokemon_name"
                echo -e "${RED}‚ùå Failed to fetch data for $pokemon_name after $MAX_RETRIES retries (Network error)${NC}"
                return 1
            else
                echo -e "${YELLOW}‚ö†Ô∏è  Network error for $pokemon_name (attempt $attempt/$max_attempts)${NC}"
                ((attempt++))
                continue
            fi
        fi
        
        # Extract HTTP status code and response body
        local http_status="${response: -3}"  # Get last 3 characters (HTTP status code)
        response="${response%???}"           # Remove last 3 characters to get actual response
        
        # Check if the request was successful
        if [[ "$http_status" -eq 200 ]]; then
            # Validate JSON before saving
            if echo "$response" | jq empty >/dev/null 2>&1; then
                # Save the response to the output file
                echo "$response" > "$output_file"
                if [[ $attempt -gt 1 ]]; then
                    echo -e "Saved data to ${output_file} ${GREEN}‚úÖ (succeeded on attempt $attempt)${NC}"
                else
                    echo -e "Saved data to ${output_file} ${GREEN}‚úÖ${NC}"
                fi
                return 0
            else
                local error_msg="Invalid JSON response received"
                if [[ $attempt -eq $max_attempts ]]; then
                    log_error "$error_msg (all $MAX_RETRIES retries exhausted)" "$pokemon_name"
                    echo -e "${RED}‚ùå Failed to save data for $pokemon_name after $MAX_RETRIES retries (Invalid JSON)${NC}"
                    return 1
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Invalid JSON for $pokemon_name (attempt $attempt/$max_attempts)${NC}"
                    ((attempt++))
                    continue
                fi
            fi
        else
            # Handle different HTTP error codes
            local error_msg
            local should_retry=true
            
            case "$http_status" in
                404)
                    error_msg="Pok√©mon '$pokemon_name' not found (HTTP 404)"
                    should_retry=false  # Don't retry for 404 errors
                    ;;
                429)
                    error_msg="Rate limit exceeded (HTTP 429)"
                    echo -e "${YELLOW}‚ö†Ô∏è  Rate limit hit for $pokemon_name (attempt $attempt/$max_attempts)${NC}"
                    if [[ $attempt -lt $max_attempts ]]; then
                        echo -e "${YELLOW}‚ö†Ô∏è  Extending delay for rate limiting...${NC}"
                        sleep 10  # Extended delay for rate limiting
                    fi
                    ;;
                500|502|503|504)
                    error_msg="Server error (HTTP $http_status)"
                    ;;
                *)
                    error_msg="API request failed with HTTP status: $http_status"
                    ;;
            esac
            
            # If this is the last attempt or we shouldn't retry
            if [[ $attempt -eq $max_attempts ]] || [[ "$should_retry" == false ]]; then
                if [[ "$should_retry" == false ]]; then
                    log_error "$error_msg (no retry - permanent error)" "$pokemon_name"
                    echo -e "${RED}‚ùå Failed to fetch data for $pokemon_name ($error_msg)${NC}"
                else
                    log_error "$error_msg (all $MAX_RETRIES retries exhausted)" "$pokemon_name"
                    echo -e "${RED}‚ùå Failed to fetch data for $pokemon_name after $MAX_RETRIES retries ($error_msg)${NC}"
                fi
                return 1
            else
                echo -e "${YELLOW}‚ö†Ô∏è  $error_msg for $pokemon_name (attempt $attempt/$max_attempts)${NC}"
                ((attempt++))
                continue
            fi
        fi
    done
    
    return 1
}

# Function to display summary statistics
display_summary() {
    local total_pokemon=${#POKEMON_LIST[@]}
    local successful_files=$(find "$OUTPUT_DIR" -name "*.json" -type f 2>/dev/null | wc -l)
    local failed_count=$((total_pokemon - successful_files))
    
    echo ""
    echo "=== Batch Processing Summary ==="
    echo "Total Pok√©mon requested: $total_pokemon"
    echo -e "Successfully fetched: ${GREEN}$successful_files${NC}"
    
    if [[ $failed_count -gt 0 ]]; then
        echo -e "Failed requests: ${RED}$failed_count${NC}"
        echo "Check $ERROR_FILE for error details."
    fi
    
    echo ""
    echo "üìÇ Output directory: $OUTPUT_DIR"
    if [[ $successful_files -gt 0 ]]; then
        echo "üìÑ Files created:"
        ls -1 "$OUTPUT_DIR"/*.json 2>/dev/null | sed 's/^/  /'
    fi
}

# Function to validate prerequisites
check_prerequisites() {
    # Check if curl is available
    if ! command -v curl >/dev/null 2>&1; then
        echo -e "${RED}‚ùå curl is not installed. Please install curl to use this script.${NC}"
        exit 1
    fi
    
    # Check if jq is available for JSON validation
    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${YELLOW}‚ö†Ô∏è  jq is not installed. JSON validation will be skipped.${NC}"
        echo "Consider installing jq for better error detection."
    fi
}

# Main execution function
main() {
    echo "=== Batch Pok√©mon Data Retrieval with Retry Logic ==="
    echo "Target API: $API_BASE_URL"
    echo "Output directory: $OUTPUT_DIR"
    echo "Pok√©mon to fetch: ${POKEMON_LIST[*]}"
    echo "Delay between requests: ${DELAY_SECONDS}s"
    echo "Max retries per Pok√©mon: $MAX_RETRIES"
    echo "Retry delay (exponential backoff): ${RETRY_DELAY}s base"
    echo ""
    
    # Check prerequisites
    check_prerequisites
    
    # Setup output directory
    setup_output_directory
    
    # Initialize counters
    local success_count=0
    local total_count=${#POKEMON_LIST[@]}
    
    # Process each Pok√©mon
    for pokemon in "${POKEMON_LIST[@]}"; do
        # Fetch data for current Pok√©mon
        if fetch_pokemon_data "$pokemon"; then
            ((success_count++))
        fi
        
        # Add delay between requests (except for the last one)
        if [[ $pokemon != "${POKEMON_LIST[-1]}" ]]; then
            sleep $DELAY_SECONDS
        fi
    done
    
    # Display final summary
    display_summary
    
    # Exit with appropriate code
    if [[ $success_count -eq $total_count ]]; then
        echo -e "${GREEN}üéâ All Pok√©mon data fetched successfully!${NC}"
        exit 0
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Some requests failed. Check the summary above.${NC}"
        exit 1
    fi
}

# Run the main function
main "$@"
